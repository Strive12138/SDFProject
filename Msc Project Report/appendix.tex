\begin{appendices}
\chapter{Premake Script}
\label{ap:premake}
%Python code highlighting
\begin{lstlisting}[caption = Premake Script for solution generation]
    workspace "SDF"
    	language "C++"
    	cppdialect "C++17"
    
    	platforms { "x64" }
    	configurations { "release", "debug" }
    
    	flags "NoPCH"
    	flags "MultiProcessorCompile"
    
    	startproject "sdf"
    
    	debugdir "%{wks.location}"
    	objdir "prebuild/%{cfg.buildcfg}-%{cfg.platform}-%{cfg.toolset}"
    	targetsuffix "-%{cfg.buildcfg}-%{cfg.platform}-%{cfg.toolset}"
    
    	filter "toolset:gcc or toolset:clang"
    		linkoptions { "-pthread" }
    		buildoptions { "-march=native", "-Wall", "-pthread" }
    	filter "toolset:msc-*"
    		defines { "_CRT_SECURE_NO_WARNINGS=1" }
    		defines { "_SCL_SECURE_NO_WARNINGS=1" }
    		buildoptions { "/utf-8" }
    		
    	filter "*"
    
    	-- default libraries
    	filter "system:linux"
    		links "dl"
    	filter "system:windows"
    	
    	filter "*"
    
    	-- default outputs
    	filter "kind:StaticLib"
    		targetdir "prebuild/lib/"
    	filter "kind:ConsoleApp"
    		targetdir "prebuild/bin/"
    		targetextension ".exe"
    		
    	filter "*"
    
    	--configurations
    	filter "debug"
    		symbols "On"
    		defines { "_DEBUG=1" }
    	filter "release"
    		optimize "On"
    		defines { "NDEBUG=1" }
    	filter "*"
    
    include "extern" 
    
    project "sdf"
    	includedirs( "src" );
    	local sources = { 
    		"src/**.cpp",
    		"src/**.hpp",
    		"src/**.hxx",
    		"src/**.h"
    	}
    
    	kind "ConsoleApp"
    	location "src"
    
    	files( sources )
    
    	links "x-glad"
    	links "x-glad"
    	links "x-glfw"
    	links "x-tinyobj"
    	links "x-imgui"
    	dependson "x-glm" 
    
    	filter "system:linux"
    		links "tbb"
\end{lstlisting}

\clearpage

\begin{lstlisting}[caption=Premake Script for external library]
    -- Third party projects
    includedirs( "glad/include" );
    includedirs( "glfw/include" );
    includedirs( "glm" );
    includedirs( "tinyobjloader" );
    includedirs( "imgui" );
    
    project( "x-glad" )
    	kind "StaticLib"
    	location "."
    	files( "glad/src/glad.c" )
    
    
    project( "x-glfw" )
    	kind "StaticLib"
    	location "."
    	filter "system:linux"
    		defines { "_GLFW_X11=1" }
    	filter "system:windows"
    		defines { "_GLFW_WIN32=1" }
    	filter "*"
    
    	files {
    		"glfw/src/context.c",
    		"glfw/src/egl_context.c",
    		"glfw/src/init.c",
    		"glfw/src/input.c",
    		"glfw/src/internal.h",
    		"glfw/src/mappings.h",
    		"glfw/src/monitor.c",
    		"glfw/src/null_init.c",
    		"glfw/src/null_joystick.c",
    		"glfw/src/null_joystick.h",
    		"glfw/src/null_monitor.c",
    		"glfw/src/null_platform.h",
    		"glfw/src/null_window.c",
    		"glfw/src/platform.c",
    		"glfw/src/platform.h",
    		"glfw/src/vulkan.c",
    		"glfw/src/window.c",
    		"glfw/src/osmesa_context.c"
    	};
    	filter "system:linux"
    		files {
    			"glfw/src/posix_*",
    			"glfw/src/x11_*", 
    			"glfw/src/xkb_*",
    			"glfw/src/glx_*",
    			"glfw/src/linux_*",
    		};
    	filter "system:windows"
    		files {
    			"glfw/src/win32_*",
    			"glfw/src/wgl_*", 
    		};
    	filter "*"
    
    project( "x-glm" )
    	kind "Utility"
    	location "."
    	files( "glm/glm/**.h" )
    	files( "glm/glm/**.hpp" )
    	files( "glm/glm/**.inl" )
    
    project( "x-tinyobj" )
    	kind "StaticLib"
    	location "."
    	files( "tinyobjloader/tiny_obj_loader.cc" )
    
    project( "x-imgui" )
    	kind "StaticLib"
    	location "."
    	files( "imgui/imgui.cpp" )
    	files( "imgui/imgui_draw.cpp" )
    	files( "imgui/imgui_widgets.cpp" )
    	files( "imgui/imgui_tables.cpp" )
    	files( "imgui/imgui_demo.cpp" )
    	files( "imgui/backends/imgui_impl_glfw.cpp" )
    	files( "imgui/backends/imgui_impl_opengl3.cpp" )
\end{lstlisting}

\chapter{Infinity Grids Scene Shaders}
\label{ap:scene}

\begin{lstlisting}[language=C, caption = Vertex shader of Infinity Grids Scene]
	#version  460 core

	uniform mat4 MVP_INV;

	layout(location = 1) out vec3 nearPoint;
	layout(location = 2) out vec3 farPoint;

	const vec2 positions[4] = vec2[](
		vec2(-1, -1),
		vec2(+1, -1),
		vec2(-1, +1),
		vec2(+1, +1)
	);
	vec3 unproj(float x, float y, float z ) {
		vec4 hp = MVP_INV *vec4(x, y, z, 1.0);  
		// hp.y = -hp.y;
		// hp.z = -hp.z;
		return hp.xyz / hp.w;
	}
	void main() {
		vec3 p = vec3( positions[gl_VertexID], 1 ); 
		nearPoint = unproj(p.x, p.y, 0.0 ).xyz; // unprojecting on the near plane
		farPoint = unproj(p.x, p.y, 1.0 ).xyz; // unprojecting on the far plane
		
		gl_Position = vec4( positions[gl_VertexID], 1, 1.0); // using directly the clipped coordinates
	}
\end{lstlisting}

\clearpage

\begin{lstlisting}[language=C, caption = Fragment shader of Infinity Grids Scene]
	#version  460 core

	uniform mat4 MVP;
	uniform vec2 NF;
	uniform vec4 BCOLOR;

	layout(location = 1) in vec3 nearPoint;
	layout(location = 2) in vec3 farPoint;
	layout(location = 0) out vec4 outColor;

	vec4 grid(vec3 fragPos3D, float scale) {
		vec2 coord = fragPos3D.xz * scale; // use the scale variable to set the distance between the lines
		vec2 derivative = fwidth(coord);
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;
		float line = min(grid.x, grid.y);
		float minimumz = min(derivative.y, 1);
		float minimumx = min(derivative.x, 1);
		vec4 color = vec4( 0.25,0.25,0.25, 1.0 - min(line, 1.0));

		float bs = 5;

		// z axis
		if(fragPos3D.x > -bs * minimumx && fragPos3D.x < bs * minimumx)
			color.z = 1.0;
		// x axis
		if(fragPos3D.z > -bs * minimumz && fragPos3D.z < bs * minimumz)
			color.x = 1.0;
		if (color.w<=0 ) {
			discard;
		}
		return color * color.w;
	}


	float compute_linear_depth(vec3 pos) {
		vec4 clip_space_pos =  MVP * vec4(pos.xyz, 1.0);
		float clip_space_depth = (clip_space_pos.z / clip_space_pos.w) * 2.0 - 1.0; // put back between -1 and 1
		float near = NF[0];
		float far = NF[1];

		float linear_depth = (2.0 * near * far) / (far + near - clip_space_depth * (far - near)); // get linear value between 0.01 and 100
		return linear_depth / far; // normalize
	}
	void main() {
		float t = -nearPoint.y / (farPoint.y - nearPoint.y);
		if ( t<=0)
			discard;

		vec3 frag_pos = nearPoint + t * (farPoint - nearPoint);

		vec4 clip_space_pos = MVP * vec4(frag_pos.xyz, 1.0);
		clip_space_pos =  (clip_space_pos / clip_space_pos.w);

		//gl_FragDepth = clip_space_pos.z;

		float linear_depth = compute_linear_depth(frag_pos);
		float fading = max(0, (0.5 - linear_depth));


		outColor = mix ( BCOLOR, grid( frag_pos , 0.1 ), fading) ;
}
\end{lstlisting}

\chapter{Shader of ray-tracing SDF visualisation}

\begin{lstlisting}[language=C, caption = Vertex shader of ray-tracing SDF visualisation]
	#version  460 core

	uniform mat4 MVP_INV;
	
	
	layout(location = 1) out vec3 far_point;
	
	
	
	const vec2 positions[4] = vec2[](
		vec2(-1, -1),
		vec2(+1, -1),
		vec2(-1, +1),
		vec2(+1, +1)
	);
	
	vec3 unproj(float x, float y, float z ) {
		vec4 hp = MVP_INV *vec4(x, y, z, 1.0);  
		return hp.xyz / hp.w;
	}
	
	void main() {
		vec3 p = vec3( positions[gl_VertexID], 1 ); 
		far_point = unproj(p.x, p.y, 1.0 ).xyz; // unprojecting on the far plane
		
		gl_Position = vec4( positions[gl_VertexID], 1, 1.0); // using directly the clipped coordinates
	}
\end{lstlisting}

\clearpage

\begin{lstlisting}[language=C, caption = Fragment shader of ray-tracing SDF visualisation]
	#version 460

	uniform mat4  MVP;
	uniform vec3  CAMERA_POS;
	uniform vec3  BOX0;
	uniform vec3  BOX1;

	uniform sampler3D VOXELS;

	layout(location = 1) in vec3 far_point;
	layout(location = 0) out vec4 out_color;

	const float ESP = 0.1;


	float sdf_box(vec3 pos, vec3 hsize) {
	vec3 q = abs(pos) - hsize;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
	}

	// Definition of signed distance funtion called from
	float SDF(vec3 pos) {
	vec3 center = (BOX1 + BOX0) * 0.5;
	vec3 size = (BOX1 - BOX0);
	vec3 hsize = size * 0.5;

	float s =  sdf_box(pos - center, hsize);

	if ( s < ESP ) {


		vec3 uvw = (pos - BOX0) /size ;

		return texture( VOXELS,uvw ).x;

	}
	return s ;

	}

	void main() {

	
	vec3 D = normalize( far_point - CAMERA_POS ); 
	vec3 P = CAMERA_POS; // the current ray position
	for(int i = 0; i < 30; ++i) {
		float s0 = SDF(P);
		// if(s0 < 0 ) { // ray starting from inside the object
		//   out_color = vec4(1, 0, 0, 1); // paint red
		//   return;
		// }
		if( s0 < ESP ) { // the ray hit the implicit surfacee
		float eps = ESP;
		float sx = SDF(P + vec3(eps, 0, 0)) - s0;
		float sy = SDF(P + vec3(0, eps, 0)) - s0;
		float sz = SDF(P + vec3(0, 0, eps)) - s0;
		vec3 nrm = normalize(vec3(sx, sy, sz)); // normal Dection
		float c = - dot(nrm, D); // Lambersian reflection. The light is at the camera position.
		out_color = vec4(c, c, c, 1);

		vec4 clip_space_pos = MVP * vec4( P.xyz, 1.0);
		clip_space_pos =  (clip_space_pos / clip_space_pos.w);
		gl_FragDepth = clip_space_pos.z;
				
		return;
		}
		P += s0 * D; // advance ray
	}
	discard;
}

\end{lstlisting}

\end{appendices}